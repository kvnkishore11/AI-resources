# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

Never use Generated by Claude Code in the code comments or coauthored by Claude Code in the commit messages.

# Coding pattern preferences

- Always prefer simple solutions
- Avoid duplication of code whenever possible, which means checking for other areas of the codebase that might already have similar code and functionality
- Write code that takes into account the different environments: dev, test, and prod
- You are careful to only make changes that are requested or you are confident are well understood and related to the change being requested
- When fixing an issue or bug, do not introduce a new pattern or technology without first exhausting all options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't have duplicate logic.
- Keep the codebase very clean and organized
- Avoid writing scripts in files if possible, especially if the script is likely only to be run once
- Avoid having files over 200-300 lines of code. Refactor at that point.
- Mocking data is only needed for tests, never mock data for dev or prod
- Never add stubbing or fake data patterns to code that affects the dev or prod environments
- Never overwrite my .env file without first asking and confirming



# Cursor Rule: Enforcing SOLID Principles and OOP Best Practices

## Rule Overview
This rule enforces adherence to SOLID principles and object-oriented programming (OOP) concepts throughout the codebase to improve maintainability, extensibility, and testability.

## Detailed Description

### SOLID Principles Implementation

#### Single Responsibility Principle (SRP)
- Each class should have only one reason to change
- Classes should be small, focused, and handle a single concern
- Identify when a class is doing too much (>200-300 lines is a warning sign)
- Extract separate responsibilities into their own classes
- Example: Separate data access, business logic, and presentation logic

#### Open/Closed Principle (OCP)
- Design classes to be extended without modifying existing code
- Use inheritance and interfaces to allow new behavior without changing existing code
- Avoid extensive conditional logic that requires modification for new cases
- Prefer strategy patterns and plugins over direct modification
- Example: Use abstract base classes and extension points rather than modifying existing classes

#### Liskov Substitution Principle (LSP)
- Derived classes must be completely substitutable for their base classes
- Maintain expected behavior when overriding methods
- Do not strengthen preconditions or weaken postconditions in subclasses
- Ensure derived classes respect all contracts of parent classes
- Example: Override methods without changing their fundamental behavior

#### Interface Segregation Principle (ISP)
- Create fine-grained, client-specific interfaces
- Avoid "fat" interfaces that force clients to depend on methods they don't use
- Split large interfaces into smaller, more focused ones
- Example: Define multiple small interfaces rather than a single comprehensive one

#### Dependency Inversion Principle (DIP)
- High-level modules should not depend on low-level modules
- Both should depend on abstractions
- Always inject dependencies rather than instantiating them directly
- Use dependency injection containers when appropriate
- Example: Accept interfaces as constructor parameters rather than concrete implementations

### OOP Concepts Application

#### Encapsulation
- Hide implementation details behind well-defined interfaces
- Use appropriate access modifiers (private, protected, public)
- Validate inputs and maintain invariants within classes
- Provide controlled access to state through methods
- Example: Make fields private and provide public methods to access/modify them

#### Inheritance
- Use inheritance for "is-a" relationships only
- Prefer composition over inheritance for "has-a" relationships
- Document inheritance hierarchies and their intended uses
- Keep inheritance hierarchies shallow (≤3 levels when possible)
- Example: Create specialized subclasses only when they truly represent a type of the parent

#### Polymorphism
- Design for polymorphic behavior through interfaces and abstract classes
- Use method overriding to allow different implementations of the same interface
- Apply the strategy pattern to encapsulate varying behaviors
- Example: Process different types of data through a common interface

#### Abstraction
- Focus on what objects do rather than how they do it
- Hide complex implementation details behind simple interfaces
- Use abstract classes to define partial implementations and contracts
- Example: Create domain-specific abstractions that map to business concepts

## Implementation Guidelines

1. **Code Reviews**: Check for SOLID violations in code reviews
2. **Refactoring**: Identify and refactor existing code that violates these principles
3. **Design Patterns**: Apply appropriate design patterns that support SOLID (Factory, Strategy, Observer, etc.)
4. **Testing**: Write tests that verify the behavior of interfaces rather than implementations
5. **Documentation**: Document the intent and responsibilities of classes and interfaces

## Examples of Violations to Watch For

- God classes that do everything
- Tight coupling between unrelated components
- Conditional logic based on object types
- Duplicated code across inheritance hierarchies
- Direct instantiation of dependencies
- Public fields exposing implementation details

By following this rule, the codebase will become more modular, maintainable, and adaptable to changing requirements.



# Test-Driven Development Process Guideline

When developing a new feature or making changes to existing code, adhere to the following process to ensure robust, high-quality implementations:

## 1. Write Comprehensive Unit Test Cases First

- Before implementing any feature or functionality, create unit test cases that cover all expected behaviors, edge cases, and potential failure scenarios.
- Test cases should validate the correctness of the feature, including:
   - Normal case scenarios (expected inputs and outputs)
   - Edge cases (boundary conditions, extreme values)
   - Error cases (invalid inputs, failure modes)
- Use a testing framework appropriate for the programming language (e.g., JUnit for Java, pytest for Python, Jest for JavaScript).
- Ensure test cases are clear, maintainable, and well-documented, with descriptive names that reflect the functionality being tested.

## 2. Implement the Feature

- Only after writing and verifying the unit test cases, proceed to develop the feature or code changes.
- Write clean, modular, and maintainable code that adheres to the project's coding standards and best practices.
- Ensure the implementation satisfies all test cases, with tests passing successfully before considering the feature complete.

## 3. Achieve at Least 90% Code Coverage

- Use a code coverage tool (e.g., JaCoCo for Java, coverage.py for Python, Istanbul for JavaScript) to measure the coverage of your unit tests.
- Ensure that at least 90% of the code (lines, branches, and functions) is covered by the unit tests.
- Address any uncovered code by writing additional test cases or refactoring the implementation to eliminate untested paths, while avoiding unnecessary complexity.
- Exclude non-functional code (e.g., comments, configurations) from coverage calculations, but strive for comprehensive testing of all logic.

## 4. Validate and Refactor

- Run all unit tests after implementation to confirm the feature works as expected and meets the 90% coverage requirement.
- Refactor the code if necessary to improve readability, performance, or maintainability, ensuring that all tests continue to pass.
- Update test cases if refactoring introduces new behaviors or changes existing ones.

## 5. Automate Testing

- Integrate unit tests into the project's continuous integration (CI) pipeline to ensure tests are run automatically on every code change.
- Review test results and coverage reports in the CI pipeline to catch issues early.

---

By following this test-driven development approach, you ensure that every feature is thoroughly tested, reliable, and maintainable, with a minimum of 90% code coverage to guarantee high code quality.


# Coding workflow preferences

- Focus on the areas of code relevant to the task
- Do not touch code that is unrelated to the task
- Write thorough tests for all major functionality
- Avoid making major changes to the patterns and architecture of how a feature works, after it has shown to work well, unless explicitly structed
- Always think about what other methods and areas of code might be affected by code changes



# CLAUDE - Git Commit and Code Comment Guidelines

This document outlines the standards for writing Git commit messages and code comments to maintain consistency and clarity across the project.

## Table of Contents
- [Commit Message Format](#commit-message-format)
- [Commit Types](#commit-types)
- [Title Guidelines](#title-guidelines)
- [Body Guidelines](#body-guidelines)
- [Code Comment Guidelines](#code-comment-guidelines)
- [Examples](#examples)
- [Quick Reference](#quick-reference)

## Commit Message Format

Every commit message should follow this structure:

```
<type>: <concise summary>

<detailed explanation with bullet points>

<footer with references to issues/PRs>
```

### Components:
- **Title**: `<type>: <concise summary>`
- **Body**: Detailed explanation with bullet points
- **Footer**: References to issues/PRs (if applicable)

## Commit Types

Use the following types to categorize your commits:

| Type | Description | Example |
|------|-------------|---------|
| `feat` | A new feature | `feat: add user authentication` |
| `fix` | A bug fix | `fix: resolve memory leak in data parser` |
| `docs` | Documentation changes | `docs: update API documentation` |
| `style` | Code style changes (formatting, missing semi-colons, etc) | `style: format code according to ESLint rules` |
| `refactor` | Code changes that neither fix bugs nor add features | `refactor: extract utility functions` |
| `perf` | Performance improvements | `perf: optimize database queries` |
| `test` | Adding or fixing tests | `test: add unit tests for auth service` |
| `chore` | Changes to build process, dependencies, etc | `chore: update npm dependencies` |
| `revert` | Reverting a previous commit | `revert: revert commit abc123` |

## Title Guidelines

The commit title should:

- ✅ Use imperative mood ("Add" not "Added")
- ✅ Keep under 50 characters
- ✅ No period at the end
- ✅ Be specific and descriptive

### Good Examples:
```
feat: add password reset functionality
fix: prevent race condition in data sync
docs: clarify installation instructions
```

### Bad Examples:
```
feat: Added new feature.        ❌ (past tense, period, vague)
fix: bug fix                    ❌ (too vague)
docs: Updated documentation     ❌ (past tense)
```

## Body Guidelines

The commit body should:

- Explain **WHAT** was changed and **WHY** (not HOW)
- Use bullet points with hyphens for multiple points
- Wrap text at 72 characters
- Include context and motivation for changes
- Mention any significant dependencies

### Template:
```
This commit introduces [what was changed] to address [why it was needed].

Key changes:
- [First major change and its purpose]
- [Second major change and its purpose]
- [Third major change and its purpose]

This change was necessary because [context/motivation].

Dependencies: [any new dependencies or requirements]
```

## Code Comment Guidelines

Add meaningful comments for each significant change:

### Format:
```javascript
// [<type>] <explanation and rationale>
```

### Multi-line Format:
```javascript
/* [<type>] <brief summary>
 * <detailed explanation>
 * <additional context or rationale>
 */
```

### Guidelines:
- Add comments for each significant change
- Format: `// [<type>] <explanation and rationale>`
- For multi-line changes, use block comments
- Explain both WHAT was changed and WHY
- Comments should align with commit message descriptions
- Place comments directly above the changed code

## Examples

### Example 1: Bug Fix

**Commit Message:**
```
fix: resolve memory leak in user session handler

This commit fixes a critical memory leak that occurred when user
sessions were not properly cleaned up after logout.

Key changes:
- Added proper cleanup of event listeners on session destroy
- Implemented WeakMap for session storage to allow garbage collection
- Added session timeout to prevent indefinite session retention

This fix was necessary because production servers were experiencing
OOM errors after extended runtime periods.

Fixes: #1234
```

**Code Comments:**
```javascript
// [fix] Replace Map with WeakMap to allow garbage collection of expired sessions
const sessions = new WeakMap();

/* [fix] Ensure all event listeners are removed on session cleanup
 * Previously, dangling event listeners prevented garbage collection
 * causing memory to accumulate over time
 */
function cleanupSession(sessionId) {
    const session = sessions.get(sessionId);
    if (session) {
        session.removeAllListeners();
        sessions.delete(sessionId);
    }
}

// [fix] Add automatic session timeout to prevent indefinite retention
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
```

### Example 2: Feature Addition

**Commit Message:**
```
feat: implement two-factor authentication

Added two-factor authentication support using TOTP (Time-based
One-Time Password) algorithm for enhanced security.

Key changes:
- Created new 2FA setup flow in user settings
- Added TOTP generation and validation logic
- Implemented backup codes for account recovery
- Updated login flow to check for 2FA requirement

This feature addresses user requests for enhanced account security
and helps meet compliance requirements for sensitive data handling.

Dependencies: speakeasy (for TOTP), qrcode (for QR generation)
Related: #2345, #2346
```

**Code Comments:**
```javascript
/* [feat] Generate TOTP secret for two-factor authentication
 * Uses speakeasy library to create a base32 encoded secret
 * This secret is shared between server and user's authenticator app
 */
function generateTOTPSecret(user) {
    const secret = speakeasy.generateSecret({
        name: `MyApp (${user.email})`,
        length: 32
    });
    return secret;
}

// [feat] Validate TOTP token during login to ensure 2FA compliance
async function validateTwoFactorToken(user, token) {
    // [feat] Check if user has 2FA enabled before validation
    if (!user.twoFactorEnabled) {
        return { valid: true, required: false };
    }
    
    /* [feat] Verify the provided token against user's secret
     * Window of 2 allows for time drift between devices
     */
    const verified = speakeasy.totp.verify({
        secret: user.twoFactorSecret,
        encoding: 'base32',
        token: token,
        window: 2
    });
    
    return { valid: verified, required: true };
}
```

### Example 3: Refactor

**Commit Message:**
```
refactor: simplify user authentication flow

Refactored the authentication logic to reduce complexity and improve
maintainability.

Key changes:
- Extracted validation logic into separate utility functions
- Reduced nested conditionals from 5 levels to 2
- Consolidated duplicate error handling code
- Improved function naming for clarity

This refactor makes the codebase easier to understand and reduces
the likelihood of bugs in future modifications.
```

**Code Comments:**
```javascript
/* [refactor] Extracted validation logic into pure functions
 * This separation of concerns makes testing easier and
 * reduces the complexity of the main authentication function
 */
const validators = {
    // [refactor] Centralized email validation for consistency
    isValidEmail: (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
    
    // [refactor] Extracted password strength check for reusability
    isStrongPassword: (password) => password.length >= 8 && 
                                    /[A-Z]/.test(password) && 
                                    /[0-9]/.test(password)
};

/* [refactor] Simplified authentication flow with early returns
 * Previous implementation had deeply nested if-else blocks
 * making it difficult to follow the logic flow
 */
async function authenticateUser(credentials) {
    // [refactor] Early return pattern reduces nesting
    if (!validators.isValidEmail(credentials.email)) {
        throw new AuthError('Invalid email format');
    }
    
    if (!validators.isStrongPassword(credentials.password)) {
        throw new AuthError('Password does not meet requirements');
    }
    
    // [refactor] Consolidated error handling using try-catch
    try {
        const user = await findUserByEmail(credentials.email);
        const isValid = await verifyPassword(credentials.password, user.hash);
        
        if (!isValid) {
            throw new AuthError('Invalid credentials');
        }
        
        return generateAuthToken(user);
    } catch (error) {
        // [refactor] Unified error logging and response
        logger.error('Authentication failed:', error);
        throw new AuthError('Authentication failed');
    }
}
```

## Quick Reference

### Commit Message Template
```
<type>: <concise summary under 50 chars>

<what was changed and why - wrapped at 72 chars>

<bullet points for multiple changes>
- <change 1>
- <change 2>

<additional context>

<footer with issue references>
```

### Code Comment Template
```javascript
// [<type>] <what and why>

/* [<type>] <summary>
 * <detailed explanation>
 * <rationale>
 */
```

### Checklist
Before committing, ensure:
- [ ] Commit type is appropriate
- [ ] Title is in imperative mood and under 50 characters
- [ ] Body explains what and why (not how)
- [ ] Body text is wrapped at 72 characters
- [ ] Code comments are added for significant changes
- [ ] Code comments align with commit message
- [ ] Comments explain both what and why



